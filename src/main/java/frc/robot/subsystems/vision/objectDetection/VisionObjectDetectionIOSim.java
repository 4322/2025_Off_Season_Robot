package frc.robot.subsystems.vision.objectDetection;

import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Pose3d;
import edu.wpi.first.math.geometry.Rotation3d;
import edu.wpi.first.math.geometry.Translation2d;
import edu.wpi.first.math.geometry.Translation3d;
import edu.wpi.first.math.util.Units;
import frc.robot.constants.Constants;
import frc.robot.subsystems.drive.Drive;
import frc.robot.util.Trigon.simulatedfield.SimulatedGamePieceConstants.GamePieceType;
import org.littletonrobotics.junction.Logger;

public class VisionObjectDetectionIOSim extends VisionObjectDetectionIO {

  private Drive drive;
  private Translation2d coralPosition;
  private double latestTimestamp;

  private Pose3d cameraPose = new Pose3d();
  private double cameraLensToCoralPitch;
  private double cameraLensToCoralYaw;
  private boolean calculationsDone = false;

  public VisionObjectDetectionIOSim(Drive drive) {
    this.drive = drive;
  }

  protected void updateInputs(VisionObjectDetectionInputsAutoLogged inputs) {
    if (coralPosition == null) {
      inputs.hasTarget = new boolean[Constants.VisionObjectDetection.numberOfGamePieceTypes];
      inputs.visibleObjectRotations =
          new Rotation3d[Constants.VisionObjectDetection.numberOfGamePieceTypes][0];
      inputs.objectDetected = false;
    } else {
      inputs.hasTarget = new boolean[Constants.VisionObjectDetection.numberOfGamePieceTypes];
      inputs.hasTarget[GamePieceType.CORAL.id] = true;
      inputs.visibleObjectRotations =
          new Rotation3d[Constants.VisionObjectDetection.numberOfGamePieceTypes][0];
      inputs.visibleObjectRotations[GamePieceType.CORAL.id] = new Rotation3d[1];
      inputs.visibleObjectRotations[GamePieceType.CORAL.id][0] =
          calculateRotationFromObjectPosition(coralPosition);
    }
    inputs.latestResultTimestamp = latestTimestamp;
  }

  /**
   * Inverse of calculateObjectPositionFromRotation() generated by Kimi AI Assistant:
   * https://www.kimi.com/share/d44n6d4jc3f2atkmg7q0 (except that Kimi missed calculating
   * cameraLensToCoralPitch and cameraLensToCoralYaw)
   *
   * <p>Returns the Rotation3d that would make the camera look at the given ground-plane target
   * position. Roll is implicitly zero.
   */
  public Rotation3d calculateRotationFromObjectPosition(Translation2d objectPosition) {
    /* ---- 1.  robot & camera pose at the time the picture was taken ---- */
    Pose2d robotPose = drive.getPoseAtTimestamp(latestTimestamp);
    if (robotPose == null) { // nothing to invert
      return new Rotation3d();
    }
    Logger.recordOutput("Sim/robotPoseAtTimestamp", robotPose);
    Pose3d cameraPose =
        new Pose3d(robotPose).plus(Constants.VisionObjectDetection.robotCenterToCamera);
    Logger.recordOutput("Sim/cameraPose", cameraPose);

    /* ---- 2.  3-D ground point ------------------------------------------------ */
    Translation3d groundPoint =
        new Translation3d(objectPosition.getX(), objectPosition.getY(), 0.0);

    Logger.recordOutput("Sim/groundPoint", groundPoint);

    /* ---- 3.  horizontal distance camera -> ground point ---------------------- */
    double dx = groundPoint.getX() - cameraPose.getX();
    double dy = groundPoint.getY() - cameraPose.getY();
    Logger.recordOutput("Sim/dx", dx);
    Logger.recordOutput("Sim/dy", dy);
    double groundDistance = Math.hypot(dx, dy);
    Logger.recordOutput("Sim/groundDistance", groundDistance);

    /* ---- 4.  pitch angle (positive = camera looks up) ------------------------ */
    double cameraZ = cameraPose.getZ();
    double coralToCameraPitch = Math.atan2(cameraZ, groundDistance); // always positive
    double cameraLensToCoralPitch = coralToCameraPitch - cameraPose.getRotation().getY();

    /* ---- 5.  yaw angle (robot CCW positive) ---------------------------------- */
    double yaw = Math.atan2(dy, dx);
    double cameraLensToCoralYaw = yaw - cameraPose.getRotation().getZ();

    Logger.recordOutput("Sim/yaw", Units.radiansToDegrees(cameraLensToCoralYaw));
    Logger.recordOutput("Sim/pitch", Units.radiansToDegrees(cameraLensToCoralPitch));

    /* ---- 6.  assemble Rotation3d (roll = 0) ---------------------------------- */
    // negated pitch for WPILib convention
    return new Rotation3d(0.0, cameraLensToCoralPitch, cameraLensToCoralYaw);
  }

  public void coralDetected(Translation2d pos, double timestamp) {
    coralPosition = pos;
    latestTimestamp = timestamp;
  }

  public void noCoral() {
    coralPosition = null;
  }

  public boolean isCoralDetectedInFrame() {
    if (calculationsDone) {
      if ((Math.abs(cameraLensToCoralPitch) > cameraPose.getRotation().getY()
          || Math.abs(cameraLensToCoralYaw) > cameraPose.getRotation().getX())) {
        return false;
      } else {
        return true;
      }
    } else {
      return false;
    }
  }
}
